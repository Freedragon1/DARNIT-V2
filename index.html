<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Darnit</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0b1220">

<style>
body{
  font-family:Arial;
  background:#0b1220;
  color:white;
  text-align:center;
  margin:0;
}

#game{
  display:flex;
  justify-content:center;
  gap:30px;
  margin-top:20px;
}

#grid{
  display:grid;
  grid-template-columns:repeat(4,120px);
  grid-template-rows:repeat(4,160px);
  gap:10px;
}

.cell{
  width:120px;
  height:160px;
  background:#123;
  border-radius:12px;
  border:2px solid white;
  display:flex;
  justify-content:center;
  align-items:center;
  cursor:pointer;
  position:relative;
}

.card{
  width:110px;
  height:150px;
  border-radius:10px;
}

.hint{
  position:absolute;
  font-size:64px;
  font-weight:bold;
  color:rgba(255,255,255,0.12);
  pointer-events:none;
}

#side{
  width:360px;
  display:flex;
  flex-direction:column;
  align-items:center;
}

#deckTop{
  width:120px;
  height:160px;
  border-radius:12px;
  border:4px solid lime;
  box-shadow:0 0 14px lime;
  cursor:pointer;
  transition:border-color .4s, box-shadow .4s;
}

#deckTop.locked{
  border-color:red;
  box-shadow:0 0 14px red;
}

#counter{ margin-top:10px; }

#floatImage{
  margin-top:24px;
  max-width:360px;
  max-height:440px;
  opacity:0;
  transition:opacity .4s, transform .4s;
}

#floatImage.rules{
  transform:translate(2cm, 2cm) scale(1.2);
}

#newGame{
  margin-top:4cm;
  padding:14px 40px;
  font-size:20px;
  border:none;
  border-radius:16px;
  background:#00aa66;
  color:white;
  cursor:pointer;
}

/* fireworks */
#fxCanvas{
  position:fixed;
  left:0; top:0;
  width:100vw; height:100vh;
  pointer-events:none;
  z-index:9999;
  display:none;
}
</style>
</head>

<body>
<h1 id="title">Darnit – Kings in the Corners</h1>

<canvas id="fxCanvas"></canvas>

<div id="game">
  <div id="grid"></div>

  <div id="side">
    <img id="deckTop" alt="deck">
    <div id="counter"></div>
    <img id="floatImage" src="darnitlogo.jpg" alt="info">
    <button id="newGame">New Game</button>
  </div>
</div>

<audio id="shuffleSound" src="shuffle.mp3" preload="auto"></audio>

<script>
/* ---------------- ELEMENTS ---------------- */
const gridDiv  = document.getElementById("grid");
const deckTop  = document.getElementById("deckTop");
const counter  = document.getElementById("counter");
const newGame  = document.getElementById("newGame");
const floatImg = document.getElementById("floatImage");
const shuffleSound = document.getElementById("shuffleSound");

/* ---------------- SOUNDS (LOCAL FILES) ---------------- */
const clearSound  = new Audio("clear.ogg");
const warnSound   = new Audio("boing.ogg");    // invalid placement boing
const lockSound   = new Audio("lock.mp3");
const loseSound   = new Audio("lose.mp3");     // sad trombone
const fanfareSound= new Audio("fanfare.mp3");
const crowdSound  = new Audio("crowd.mp3");

clearSound.volume   = 0.9;
warnSound.volume    = 0.9;
lockSound.volume    = 0.55;
loseSound.volume    = 0.75;
fanfareSound.volume = 0.95;
crowdSound.volume   = 0.65;

/* iPad/Safari: prime audio on first user gesture */
let soundsPrimed=false;
function primeSounds(){
  if(soundsPrimed) return;
  soundsPrimed=true;

  const sounds=[clearSound,warnSound,lockSound,loseSound,fanfareSound,crowdSound,shuffleSound];
  const vols=sounds.map(s=>s.volume ?? 1);
  sounds.forEach(s=>{ try{ s.volume=0; }catch(e){} });

  sounds.forEach(s=>{
    try{
      s.currentTime=0;
      const p=s.play();
      if(p && p.then){
        p.then(()=>{ s.pause(); s.currentTime=0; }).catch(()=>{});
      }
    }catch(e){}
  });

  setTimeout(()=>sounds.forEach((s,i)=>{ try{ s.volume=vols[i]; }catch(e){} }), 200);
}

/* ---------------- STATE ---------------- */
let grid=[], deck=[], selecting=[];
let deckLocked=false, deckHidden=true, gameOver=false;

/* ---------------- IMAGES (LOCAL CARDS) ---------------- */
const backImg="cards/back.png";

/* deck codes in your /cards folder: AS.png, 0H.png, QD.png etc */
function codeForCard(c){
  const v = (c.v===10) ? "0" : c.v; // ten is "0"
  return `${v}${c.s}`;
}
function imgFor(c){
  return `cards/${codeForCard(c)}.png`;
}
function numeric(c){ return c.v==="A"?1 : (typeof c.v==="number" ? c.v : 0); }
function isFace(c){ return ["J","Q","K"].includes(c.v); }

/* ---------------- FLOAT IMAGE ---------------- */
function showImage(src){
  floatImg.style.opacity=0;
  floatImg.className="";
  setTimeout(()=>{
    floatImg.src=src;
    if(src==="darnitrules3.jpg" || src==="darnitrules.jpg") floatImg.classList.add("rules");
    floatImg.style.opacity=1;
  },120);
}

/* ---------------- RULES ---------------- */
function allowed(i,c){
  const r=Math.floor(i/4), col=i%4;
  if(c.v==="K") return (r===0||r===3)&&(col===0||col===3);
  if(c.v==="Q") return (r===0||r===3)&&(col===1||col===2);
  if(c.v==="J") return (r===1||r===2)&&(col===0||col===3);
  return !isFace(c);
}
function canPlace(card){
  return grid.some((g,i)=>g===null && allowed(i,card));
}
function gridFull(){ return grid.every(c=>c!==null); }

/* "any removable combo adds to 10" (any size combination) */
function hasAnyMove(){
  const nums = grid.filter(c=>c && !isFace(c)).map(numeric);
  if(nums.includes(10)) return true;

  function dfs(start,sum){
    if(sum===10) return true;
    if(sum>10) return false;
    for(let i=start;i<nums.length;i++){
      if(dfs(i+1,sum+nums[i])) return true;
    }
    return false;
  }
  return dfs(0,0);
}

/* win check: no face cards left in deck AND all face cards on grid are in valid squares */
function winConditionMet(){
  if(deck.some(isFace)) return false;
  for(let i=0;i<16;i++){
    const c=grid[i];
    if(c && isFace(c) && !allowed(i,c)) return false;
  }
  return true;
}

/* ---------------- FIREWORKS ---------------- */
const fxCanvas=document.getElementById("fxCanvas");
const fxCtx=fxCanvas.getContext("2d");

function resizeFx(){
  fxCanvas.width = innerWidth * devicePixelRatio;
  fxCanvas.height = innerHeight * devicePixelRatio;
  fxCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener("resize", resizeFx);

function startFireworks(ms=2600){
  resizeFx();
  fxCanvas.style.display="block";
  let parts=[], start=performance.now();

  function burst(){
    const x=Math.random()*innerWidth;
    const y=Math.random()*innerHeight*0.4;
    for(let i=0;i<90;i++){
      const a=Math.random()*Math.PI*2;
      const s=Math.random()*6+1;
      parts.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:80,h:Math.random()*360});
    }
  }
  burst(); burst();

  function step(t){
    fxCtx.clearRect(0,0,innerWidth,innerHeight);
    parts.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.life--;
      fxCtx.fillStyle=`hsla(${p.h},90%,60%,${p.life/80})`;
      fxCtx.beginPath(); fxCtx.arc(p.x,p.y,2.3,0,Math.PI*2); fxCtx.fill();
    });
    parts = parts.filter(p=>p.life>0);

    if(t-start < ms || parts.length){
      requestAnimationFrame(step);
    }else{
      fxCanvas.style.display="none";
    }
  }
  requestAnimationFrame(step);
}

/* ---------------- END STATES ---------------- */
function winWithDrama(){
  if(gameOver) return;
  gameOver=true;
  setTimeout(()=>{
    showImage("youwin2.jpg");
    startFireworks();
    fanfareSound.currentTime=0;
    crowdSound.currentTime=0;
    fanfareSound.play().catch(()=>{});
    setTimeout(()=>crowdSound.play().catch(()=>{}), 600);
  }, 900);
}

function loseWithDelay(img){
  if(gameOver) return;
  gameOver=true;
  setTimeout(()=>{
    showImage(img);
    loseSound.currentTime=0;
    loseSound.play().catch(()=>{});
  }, 1000);
}

/* Face-card instant loss: ONLY when deck is visible, unlocked, and grid not full */
function checkImmediateFaceLoss(){
  if(gameOver || deckLocked || deckHidden || !deck.length || gridFull()) return;
  const c = deck[deck.length-1];
  if(isFace(c) && !canPlace(c)){
    // optional warning boing first (you liked it)
    warnSound.currentTime=0;
    warnSound.play().catch(()=>{});
    // after 1s we show jack/queen/king jpg + trombone
    loseWithDelay(c.v==="K" ? "king.jpg" : c.v==="Q" ? "queen.jpg" : "jack.jpg");
  }
}

/* ---------------- CLICK CELL ---------------- */
function clickCell(i){
  if(gameOver) return;

  // Placement phase
  if(!grid[i] && !deckHidden && !deckLocked){
    const card = deck.pop();
    if(!allowed(i,card)){
      warnSound.currentTime=0;
      warnSound.play().catch(()=>{});
      deck.push(card);
      return;
    }

    grid[i]=card;
    selecting=[];
    render(); // show the placed card immediately

    // win can happen immediately after a placement
    if(winConditionMet()){ winWithDrama(); return; }

    // grid just became full -> lock deck + hide top card immediately
    if(gridFull()){
      deckLocked=true;
      deckHidden=true;
      lockSound.currentTime=0;
      lockSound.play().catch(()=>{});
      render(); // IMPORTANT: hides top card immediately

      // if the full grid is actually a win, win takes precedence
      if(winConditionMet()){ winWithDrama(); return; }

      // forced-loss: no removable combos on the FULL grid
      if(!hasAnyMove()){ loseWithDelay("youlosegrid.jpg"); return; }

      // otherwise show "grid full" prompt image
      showImage("gridfull3.jpg");
      return;
    }

    // if not full, then we may need immediate face-loss check for the newly revealed top card
    checkImmediateFaceLoss();
    return;
  }

  // Removal phase
  if(!deckLocked) return;

  // Clicking an empty (cleared) square resets selection sum (your request)
  if(!grid[i]){
    selecting=[];
    render();
    return;
  }

  const c = grid[i];
  if(isFace(c)) return; // picture cards cannot be removed

  // Single 10 removal
  if(numeric(c)===10){
    grid[i]=null;
    selecting=[];
    clearSound.currentTime=0;
    clearSound.play().catch(()=>{});
    render();
    return;
  }

  // Multi-card selection
  selecting.includes(i) ? selecting=selecting.filter(x=>x!==i) : selecting.push(i);
  const sum = selecting.reduce((s,k)=>s + numeric(grid[k]), 0);

  if(sum===10){
    selecting.forEach(k=>grid[k]=null);
    selecting=[];
    clearSound.currentTime=0;
    clearSound.play().catch(()=>{});
  }else if(sum>10){
    selecting=[];
  }

  render();
}

/* ---------------- DECK CLICK ---------------- */
deckTop.onclick = ()=>{
  if(gameOver) return;
  if(!deckLocked) return;
  if(gridFull()) return; // must have at least one free space

  deckLocked=false;
  deckHidden=false;
  selecting=[];
  showImage("darnitlogo.jpg");
  render();
  checkImmediateFaceLoss();
};

/* ---------------- NEW GAME ---------------- */
newGame.onclick = ()=>{
  // user gesture -> allow audio immediately on iPad
  primeSounds();

  const vals=["A",2,3,4,5,6,7,8,9,10,"J","Q","K"];
  const suits=["S","H","D","C"];
  deck=[];
  suits.forEach(s=>vals.forEach(v=>deck.push({v,s})));
  deck.sort(()=>Math.random()-0.5);

  grid=Array(16).fill(null);
  selecting=[];
  deckLocked=false;
  deckHidden=true;
  gameOver=false;

  showImage("darnitrules3.jpg"); // (use darnitrules.jpg if that’s your file)
  render();

  shuffleSound.currentTime=0;
  shuffleSound.play().catch(()=>{});
  shuffleSound.onended=()=>{
    deckHidden=false;
    render();
    checkImmediateFaceLoss();
  };
};

/* ---------------- RENDER ---------------- */
function hintFor(i){
  const r=Math.floor(i/4), c=i%4;
  if((r===0||r===3)&&(c===0||c===3)) return "K";
  if((r===0||r===3)&&(c===1||c===2)) return "Q";
  if((r===1||r===2)&&(c===0||c===3)) return "J";
  return null;
}

function render(){
  gridDiv.innerHTML="";

  grid.forEach((c,i)=>{
    const d=document.createElement("div");
    d.className="cell";

    if(c){
      const img=document.createElement("img");
      img.src=imgFor(c);
      img.className="card";
      d.appendChild(img);
    }else{
      const h=hintFor(i);
      if(h){
        const s=document.createElement("div");
        s.className="hint";
        s.textContent=h;
        d.appendChild(s);
      }
    }

    d.onclick=()=>clickCell(i);
    gridDiv.appendChild(d);
  });

  counter.textContent="Cards remaining: "+deck.length;

  deckTop.className = deckLocked ? "locked" : "";
  deckTop.src = (deckHidden || !deck.length) ? backImg : imgFor(deck[deck.length-1]);

  // only check face-loss when it makes sense
  checkImmediateFaceLoss();
}

/* ---------------- SERVICE WORKER REGISTER ---------------- */
if("serviceWorker" in navigator){
  window.addEventListener("load", async ()=>{
    try{
      await navigator.serviceWorker.register("./sw.js", { scope: "./" });
    }catch(e){
      console.log("SW register failed:", e);
    }
  });
}

render();
</script>
</body>
</html>
